-------------------------------------------------------------------------------------------------------------------
Q.1)
/* To create 'n' children. When the children will terminate, display total cumulative time children spent in user and kernel mode. */
#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include<sys/times.h>
#include<stdlib.h>
int main(void)
{
	int i,status;
	pid_t pid;
	time_t currentTime;
	struct tms cpuTime;
	
	if((pid = fork())== -1)
	{
		perror("fork error");
		exit(EXIT_FAILURE);
       	}
	else if(pid==0)
		{
			time(&currentTime);
			printf("Child proccess started at %s",ctime(&currentTime));
			for(i=0;i< 5; ++i)
			{
				printf("Counting: %d \n",i);
				sleep(i);
			}
			time(&currentTime);
			printf("Child Process ended at %s",ctime(&currentTime));
			exit(EXIT_SUCCESS);
		}
	else{
		time(&currentTime);
		printf("Parent process Started at %s",ctime(&currentTime));

		if(wait(&status)== -1)
			perror("wait error");
		if(WIFEXITED(status))
			printf("Child Process ended normally");
		else
			printf("Child Process did not ended normally\n");

		if(times(&cpuTime)<0)
			perror("Times error");
		else {
			printf("Parent process user time = %ld \n",((double) cpuTime.tms_utime)/_SC_CLK_TCK);
			
			printf("Parent process system time = %ld \n",((double) cpuTime.tms_stime)/_SC_CLK_TCK);

			printf("Child process user time = %ld \n",((double) cpuTime.tms_cutime)/_SC_CLK_TCK);

			printf("Child process system time = %ld \n",((double) cpuTime.tms_cstime)/_SC_CLK_TCK);
		}
		time(&currentTime);
		printf("Parent Process ended at %s",ctime(&currentTime));
		exit(EXIT_SUCCESS);
	
	}
}
-----------------------------------------------------------------------------------------------------------------------------
Q.2)
/* To generate parent process to write unnamed pipe and will read from it. */

#include<stdio.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include<sys/times.h>
#include<stdlib.h>

int main(void)
{
	int i,status;
	pid_t pid;
	time_t currentTime;
	struct tms cpuTime;
	
	if((pid = fork())== -1)
	{
		perror("fork error");
		exit(EXIT_FAILURE);
       	}
	else if(pid==0)
		{
			time(&currentTime);
			printf("Child proccess started at %s",ctime(&currentTime));
			for(i=0;i< 5; ++i)
			{
				printf("Counting: %d \n",i);
				sleep(i);
			}
			time(&currentTime);
			printf("Child Process ended at %s",ctime(&currentTime));
			exit(EXIT_SUCCESS);
		}
	else{
		time(&currentTime);
		printf("Parent process Started at %s",ctime(&currentTime));

		if(wait(&status)== -1)
			perror("wait error");
		if(WIFEXITED(status))
			printf("Child Process ended normally");
		else
			printf("Child Process did not ended normally\n");

		if(times(&cpuTime)<0)
			perror("Times error");
		else {
			printf("Parent process user time = %ld \n",((double) cpuTime.tms_utime)/_SC_CLK_TCK);
			
			printf("Parent process system time = %ld \n",((double) cpuTime.tms_stime)/_SC_CLK_TCK);

			printf("Child process user time = %ld \n",((double) cpuTime.tms_cutime)/_SC_CLK_TCK);

			printf("Child process system time = %ld \n",((double) cpuTime.tms_cstime)/_SC_CLK_TCK);
		}
		time(&currentTime);
		printf("Parent Process ended at %s",ctime(&currentTime));
		exit(EXIT_SUCCESS);
	
	}
}

------------------------------------------------------------------------------------------------------------------------
Q.3)
/* to create a file with a hole in it */
#include<stdio.h>
#include<fcntl.h>
#include"string.h"

int main()
{
    
    
    int n=creat("file.txt",0777); 
    
    char ch[16]="hello world how are";
    char str[20]="od -c file.txt";
  

    system("chmod 777 file.txt");

        

   write(n,ch,16);

     

    lseek(n,48,SEEK_SET);
       

  write(n,ch,16);
    
    system(str);
    return(0);
}
--------------------------------------------------------------------------------------------------------------------------------
Q.4)
/* Takes multiple files as command line arguments and print their inode number */
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
int main (int argc, char *argv[])
{
    struct stat fileStat;
    int fd=0,i;
    FILE *filename;


    for(i=0;i<argc;i++)
    {
          filename = argv[i];

          if ( ( fd = open (filename , O_RDONLY) ) == -1)
          {
                perror ( "open " );
                system("pause");
                exit (1) ;
          }

          if(fstat(fd, &fileStat)<0) return 1;

    
          printf("Inode for %s\n",filename);
          printf("---------------------------\n");
          //printf("File Size: \t\t%d bytes\n",fileStat.st_size);
          //printf("Number of Links: \t%d\n",fileStat.st_nlink);
          printf("File inode: \t\t%d\n\n",fileStat.st_ino);

     }    
     //printf("\n%d\n",argc);
     //printf("\n%s\n",argv[0]);
    return 0;
}
----------------------------------------------------------------------------------------------------------------------------------
Q.5)
/* To handle the two-way communication between parent and child using pipe. */

#include<stdio.h>
#include<unistd.h>

int main()
{
	int pipefds1[2],pipefds2[2];
	int returnstatus1, returnstatus2;
	int pid;
	char pipe1writemessage[20]="Good";
	char pipe2writemessage[20]="Nice";
	char readmessage[20];
	returnstatus1=pipe(pipefds1);

	if(returnstatus1 == -1)
	{
		printf("Unable to create pipe 1\n");
		return 1;
	}
	returnstatus2 = pipe(pipefds2);

	if(returnstatus2 == -1)
	{
		printf("Unable to create pipe 2 \n");
		return 1;
	}

	pid=fork();

	if(pid!=0)
	{
		close(pipefds1[0]);
		close(pipefds2[1]);
		printf("In Parent : Writing to pipe 1 - Message is %s \n",pipe1writemessage);
		write(pipefds1[1],pipe1writemessage,sizeof(pipe1writemessage));
		read(pipefds2[0],readmessage,sizeof(readmessage));
		printf("In Parent: Reading from pipe 1 - Message is %s \n",readmessage);
	}
	else
	{
		close(pipefds1[1]);
		close(pipefds2[0]);
		read(pipefds1[0],readmessage,sizeof(readmessage));
		printf("In child: Reading from pipe 1 - Message is %s \n",readmessage);
		printf("In child: Writing to pipe 2 -Message is %s \n",pipe2writemessage);
		write(pipefds2[1],pipe2writemessage,sizeof(pipe2writemessage));
	}
	return 0;
}

------------------------------------------------------------------------------------------------------------------------------
Q.6)
/* Print the type of file where file name accepted through Command Line. */
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

int main(int argc,char *argv[])
{
	struct stat fileStat;
	int inode;
	int fd;
	int i;

	if(argc < 2)
	{
		fprintf(stderr,"usage: %s <file>\n",argv[0]);
		return 1;
	}
	else
	{
		printf("cc=%d\t%s",argc,argv[2]);
		for(i=0;i<argc;i++)
		{
			fd=open(argv[i],O_RDONLY);
			if(fd == -1)
			{
				perror("open");
				return 1;
			}
			if(fstat(fd,&fileStat)<0)return 1;
			else
			{
				printf("Information for %s\n",argv[i]);
				printf("---------------\n");
				printf("Type of file:\t%d\n",fileStat.st_mode);
	                }
		}
	}

}

---------------------------------------------------------------------------------------------------------------
Q.7)
/* To demonstate the use of atexit() function */ 
#include <stdio.h>
#include <stdlib.h>

void out (void)
{
    printf ("atexit() succeeded!\n");
}
int main (void)
{
    if (atexit (out))
        fprintf(stderr, "atexit() failed!\n");
    return 0;
}

------------------------------------------------------------------------------------------------------------
Q.8)
/* Open a file goes to sleep for 15 seconds before terminating. */
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

int main()
{
	char fnm[20];
	int fp;
	struct stat st;
	printf("\n Enter the filename :");
	scanf("%s",fnm);

	fp=open(fnm,O_RDONLY);
	if(fp < 0)
	     printf("\n File openinng error");
	else
	{
	     sleep(15);
		
	}
	close(fp);

}

--------------------------------------------------------------------------------------------------------------
Q.9)
/* To print the size of the file */
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
int main (int argc, char *argv[])
{
    struct stat fileStat;
    int fd=0;
    FILE *filename;
    
    filename = (FILE *)argv[1];
    //printf("\n%s\n",argv[1]);

    if ( ( fd = open (filename , O_RDONLY) ) == -1)
    {
         perror ("open ");
         system("pause");
         exit (1) ;
    }

    if(fstat(fd, &fileStat)<0) return 1;
    printf("File Size: \t\t%d bytes\n",fileStat.st_size);
    printf("Mode: \t\t%d\n",fileStat.st_mode);
    return 0;
}

----------------------------------------------------------------------------------------------------------
Q.10)
/* Read the current directory and display the names of files , no of files in the current directory */
#include <stdio.h>
#include <dirent.h>
int main()
{ 
      struct dirent *de;  //pointer to directory entry
      DIR *dr = opendir("."); //open current directory
      int cnt = 0;
      if(dr == NULL)  // check if directory not exist
      {
           printf("Cannot open a file \n");
           return 0;
      }
      printf("Files in current Directory :\n");
      while((de = readdir(dr))!= NULL )
      {
           printf("%s \n", de->d_name);
           cnt++; 
      }
      printf("\nTotal Number of Files in current directory : %d\n",cnt);
      return 1;
}

-------------------------------------------------------------------------------------------------
Q.11)
/* Write a C program to implement the following unix/linux command (use fork, pipe and exec system call) */


#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(int argc,char** argv)
{
	int des_p[2];
	if(pipe(des_p) == -1)
	{
		perror("Pipe Failed");
		exit(1);
	}
	if(fork()==0)
	{
		close(STDOUT_FILENO);
		dup(des_p[1]);
		close(des_p[0]);
		close(des_p[1]);

		const char* progl[] = {"ls","-l",0};
		execvp(progl[0],progl);
		perror("execvp of ls failed");
		exit(1);
	}

	if(fork()==0)
	{
		close(STDIN_FILENO);
		dup(des_p[0]);
		close(des_p[1]);
		close(des_p[0]);

		const char* prog2[] = {"wc","-l",0};
		execvp(prog2[0],prog2);
		perror("execvp of wc failed");
		exit(1);
	}

}
---------------------------------------------------------------------------------------------------
Q.12)
/* Write a C program to display all the files from current directory which are created in particular month */
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<dirent.h>
#include<string.h>
#include<time.h>


int main(void)
{
	struct dirent *de;
	struct stat filestat;
	char dirnm[80];

	strcpy(dirnm,getcwd(dirnm,sizeof(dirnm)));
	char mn[20];
	printf("\n Enter the month: ");
	scanf("%s",&mn);
	printf("\n Current Dir = %s\n",dirnm);
	DIR *dr = opendir(dirnm);

	if(dr==NULL)
	{
		printf("Could not open current Directory");
		return 0;
	}
	printf("Files created in the month if %s are : \n",mn);

	while((de = readdir(dr)) != NULL)
	{
		if(stat(de->d_name,&filestat)<0)
			printf("Error");
		else
		{
			//printf("%s",ctime(&filestat.st_mtime));
			if(strstr(ctime(&filestat.st_mtime),mn))
				printf("%s\n",de->d_name);
		}
	}
	closedir(dr);
	return 0;

}
-----------------------------------------------------------------------------------------------------------------------
Q.13)
/* Write a C program to display all the files from current directory whose size is greater that n Bytes Where n is accepted from user */
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<dirent.h>
#include<string.h>

int main(void)
{
	struct dirent *de;
	struct stat filestat;
	char dirnm[80];
	int sz;

	printf("Enter how many bytes :");
	scanf("%d",&sz);

	strcpy(dirnm,getcwd(dirnm,sizeof(dirnm)));
	printf("\n Current Dir = %s\n",dirnm);
	DIR *dr = opendir(dirnm);

	if(dr==NULL)
	{
		printf("Could not open current Directory \n");
		return 0;
	}
	printf("Files are : \n");
	while((de = readdir(dr)) != NULL)
	{
		if(stat(de->d_name,&filestat)<0)
			printf("Error");
		else
		{
			printf("%d",&filestat.st_size);
			if((filestat.st_size) > sz)
				printf("%s\n",de->d_name);
		}
	}
	closedir(dr);
	return 0;

}

---------------------------------------------------------------------------------------------------------------------------------------
Q.14)/* Write a C program to implement the following unix/linux command
         ls -l > output.txt              */
#include<stdio.h>
#include<sys/stat.h>
#include<stdlib.h>
#include<unistd.h>

int spwan(char *program, char **arg_list)
{
	pid_t child_pid;
	child_pid=fork();
	if(child_pid!=0)
	{
		return child_pid;
	}
	else
	{
		execvp(program,arg_list);
		fprintf(stderr,"An error occured in execvp");
		abort();
		
	}
}
int main()
{
	char *arg_list[]={"ls","-l","/",NULL};
	spwan("ls",arg_list);
	printf("Done with main program");
	return 0;
}
---------------------------------------------------------------------------------------------------------------------------------------
Q.15)/* Write a c programm  that display information of a given file similar to given by unix/linux
	          ls -l <filename> */

#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
int spawn ( char * program ,char **arg_list )
{
	pid_t child_pid;
	child_pid =fork();
	if ( child_pid !=0 )
	{
		return child_pid;
	}
	else
	{
	execvp ( program ,arg_list );
	fprintf(stderr,"An error occured in execvp");
	abort();
	}	
}

int main ( int argc , char *argv[] )
{
	char * fd =argv[1];
	char *arg_list[]={
		"ls", "-l", fd,
		NULL};
	spawn ("ls" , arg_list);
	printf("%s", fd);
	return 0;
}
-----------------------------------------------------------------------------------------------------------------
Q.16)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”. Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should additionally interpret the following command
i)count c <filename> - print number of characters in file
ii) count w <filename> - print number of words in file
iii)count l <filename> - print number of lines in file
*/

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<sys/stat.h>

int main()
{
	char cmd[80],t1[20],t2[20],t3[20],ch;
	int charcnt=0,linecnt=0,wcnt=0;
	FILE *fp;
	int pid;

	pid=vfork();
	printf("PP = %d",pid);
	if(pid==0)	
	{
		while(1)
		{
			printf("\n NewShell$:");
			gets(cmd);
			sscanf(cmd,"%s %s %s",t1,t2,t3);

			if(strcmp(t1,"count")==0)
			{
				switch(t2[0])
				{
					case 'c' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
					           {
						   	charcnt++;
						   }
						   printf("\n No of chars = %d",charcnt);
						   fclose(fp);
						   break;
				 	case 'l' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
						   {
						   	if(ch=='\n')linecnt++;
						   }
						   printf("\n No of lines = %d",linecnt);
						   fclose(fp);
						   break;
					case 'w' : fp=fopen(t3,"r");
						   while((ch=getc(fp))!=EOF)
						   {
						   	if(ch=='\n' || ch==' ')
								wcnt++;
						   }
						   printf("\n No of words = %d",wcnt);
						   fclose(fp);
						   break;
				 	default : printf("Invalid Choice");
						  break;
				}
			}
			else
			{
				printf("Invalid Option");
				exit(0);
			}
		}
	}
}
----------------------------------------------------------------------------------------------------------------------------------------
Q.17)
/* 17. Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”. Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should additionally interpret the following command.
i) list f <dirname> - print name of all files in directory
ii) list n <dirname> - print number of all entries
iii) list i<dirname> - print name and inode of all files  */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>
#include<dirent.h>
int main()
{
    char command[30],cmd[10],dnm[50],op[50],func[50];
    DIR *dp;
    struct dirent *dirf;
    int file,pid,cnt=0;

    while(1)
    {
         printf("\n ---");
         gets(func);
         sscanf(func,"%s %s %s",cmd,op,dnm);
         pid=fork();
         if(pid==0)
         {
                if(strcmp(cmd,"list")==0)
                {
                      if(op[0]=='f')
                      {
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               printf("\n Name %s",dirf->d_name);
                          }
                         closedir(dp);
                      } 
                      if(op[0]=='n')
                      {
                          cnt=0;
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               cnt++;
                          }
                          printf("\n Number of files %d",cnt);
                          closedir(dp);
                      }
                      if(op[0]=='i')
                      {
                          dp=opendir(dnm);
                          while((dirf=readdir(dp))!=NULL)
                          {
                               printf("\n File name=%s and inode=%d \n",dirf->d_name,dirf->d_ino);
                          }
                          closedir(dp);
                      } 
                 }
                 else if(strcmp(cmd,"exit")==0)
                 {
                         exit(0);
                 }
            }  
      }
}
--------------------------------------------------------------------------------------------------------------------------------------
Q.18)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say "NewShell$". Any normal shell command is executed from your shell by starting a child process to execute the system
program corresponding to the command. It should additionally interpret the following command.
i) typeline +10 <filename> - print first 10 lines of file
ii) typeline -20 <filename> - print last 20 lines of file
iii) typeline a <filename> - print all lines of file */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>

int main()
{
	FILE *fp;
	int n,cnt2,cnt=1,flag=0,pid,i=0;
	char func[50],cmd[50],fnm[50],op[50],line[80],buff[80],ch;

	while(1)
	{
		printf("\n New Shell $ # ");
		gets(func);
		sscanf(func,"%s %s %s",cmd,op,fnm);
		if(strcmp(cmd,"typeline")==0)
		{
			fp=open(fnm,O_RDONLY);
			if(fp==-1)
			{
				printf("\n File Not Found");
			}
			else
			{
				if(op[0]=='+')
				{
    					cnt=1;
    					n=atoi(op);
    					printf("\n First %d lines are",n);
    					while(cnt<=n)
    					{
        					read(fp,buff,1);
        					ch=buff[0];
        					printf("%c",ch);
        					if(ch=='\n')
      	 						cnt++;
    					}
    					close(fp);
				}
				else if(op[0]=='a')
					{
    						fp=open(fnm,O_RDONLY);
						while(read(fp,buff,1)!=0)
						{
							ch=buff[0];
							printf("%c",ch);
						}
						close(fp);
					}
					else if(op[0]=='-')
						{
							cnt=0;
							fp=open(fnm,O_RDONLY);
							n=atoi(op);
							printf("Print last %d lines \n",n);
							while(read(fp,buff,1)!=0)
							{
								ch=buff[0];
								if(ch=='\n')
								{
									cnt++;
								}
							}
							cnt2=cnt+n;
							int x=1;
							cnt=0;
							lseek(fp,0,SEEK_SET);
							while(x<=cnt2)
							{
    								read(fp,buff,1);
    								ch=buff[0];
    								if(ch=='\n')
    								{
        								x++;
    								}
							}
							while(read(fp,buff,1)!=0)
							{
    								ch=buff[0];
    								printf("%c",ch);
							}
							close(fp);
						}
			}
		}
	}	
}
------------------------------------------------------------------------------------------------------------------------------------------------
Q.19)
/* Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”.Any normal shell command is executed from your shell by starting a child process to execute the system program corresponding to the command. It should
i) additionally interpret the following command.
ii) search f <pattern> <filename> - search first occurrence of pattern in filename
iii) search c <pattern> <filename> - count no. of occurrences of pattern in filename
iv) search a <pattern> <filename> - search all occurrences of pattern in filename */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>

int main()
{
      FILE *fp;
      int n,cnt=1,flag=0,pid,i=0;
      char func[50],cmd[50],fnm[50],op[50],pat[50],line[80],buff[80],ch;

      while(1) 
      {

           printf("\n New Shell $ # ");
           gets(func);
           sscanf(func,"%s %s %s %s",cmd,op,pat,fnm);
           pid=fork();
           if(pid==0)
           {
              if(strcmp(cmd,"search")==0)
              {
                  fp=open(fnm,O_RDONLY);
                  if(fp==-1)
                  {
                        printf("\n File Not Found");
                  }
                  else
                  { 
                       if(op[0]=='f')
                       {
                            while(read(fp,buff,1)!=0)
                            {

                                   ch=buff[0];
                                   if(ch!='\n')
                                   {
                                       line[i]=ch;
                                       i++;
                                   }
                                   if(ch=='\n')
                                   { 
                                       line[i]=ch;
                                       if(strstr(line,pat)!=NULL)
                                       {
                                            flag=1;
                                            printf("Pattern found %s cnt=%d",pat,cnt);
                                            break;
                                       }
                                       else
                                       {
                                             flag=0;
                                             cnt++;
                                       }
                                       i=0;
                                    }
                             }
                             if(flag==0)
                             { 
                                   printf("\nPattern not found\n"); 
                             }

                        }          

                        else if(op[0]=='a')
                        {
                             while(read(fp,buff,1)!=0)
                             {
                                  ch=buff[0];
                                  if(ch!='\n')
                                  {
                                       line[i]=ch;
                                       i++;
                                  } 
                                  if(ch=='\n') 
                                  {
                                      if(strstr(line,pat)!=NULL)
                                      {
                                           flag=1;
                                           printf("\n Pattern found %s cnt=%d",pat,cnt);
                                           cnt++;
                                      }
                                      else
                                      {
                                           flag=0;
                                           cnt++;
                                      }
                                      i=0;
                                  } 
                              }
                              if(flag==0)
                              { 
                                     printf("\nPattern not found\n"); 
                              }

                         } 
                         else if(op[0]=='c')
                         {
                               cnt=0;
                               while(read(fp,buff,1)!=0)
                               {
                                     ch=buff[0];
                                     if(ch!='\n')
                                     {
                                           line[i]=ch;
                                           i++;
                                     }
                                     if(ch=='\n')
                                     {
                                           if(strstr(line,pat)!=NULL)
                                           {
                                                flag=1;
                                                cnt++;
                                           }
                                           i=0;
                                     }
                                }
                                printf("\n\n Pattern %s and at cnt=%d",pat,cnt);
                          }
                 }
          }
          else if(strcmp(cmd,'exit')==0)
          {
                exit(0);
          }
      }     
   }
}
-----------------------------------------------------------------------------------------------------------------------------------------
Q.20)
/* Write a C program which recieves file names as command line arguments and display those file names in ascending order according to their sizes 
i)(e.g. $ a.out a.txt b.txt c.txt , ...)  */

#include<stdio.h>
#include<string.h>
#include<sys/stat.h>

//sort file according to size of file
struct list
{
	char fname[20];
	int size;
}l[10];


void main(int argc,char *argv[])
{
	int i=0,j;
	struct stat sbuff;
	struct list temp;
	for(i=1;i<argc;i++)
	{
		stat(argv[i],&sbuff);
		strcpy(l[i-1].fname,argv[i]);
		l[i-1].size=sbuff.st_size;
	}
	
	//bubble sort
	for(i=0;i<argc-1;i++)
	{
		for(j=i+1;j<argc-1;j++)
		{
			if(l[i].size > l[j].size)
			{
				strcpy(temp.fname,l[j].fname);
				temp.size=l[j].size;
				strcpy(l[j].fname,l[i].fname);
				l[j].size=l[i].size;
				strcpy(l[i].fname,temp.fname);
				l[i].size=temp.size;
				
			}
		}
	}
	//printing
	printf("File Name\t File Size\n");
	
	for(i=0;i<argc-1;i++)
	{
		printf("\n%s\t%d",l[i].fname,l[i].size);
	}
	
}

----------------------------------------------------------------------------------------------------------------------------------------------
Q.21)
/*Write a C program which create a child process which catch a signal sighup, sigint and sigquit. The Parent process send a sighup or sigint signal after every 3 seconds, at the end of 30 second parent send sigquit signal to child and child terminates my displaying message 
"My DADDY has Killed me!!!.*/

#include <signal.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 

// function declaration 
void sighup(); 
void sigint(); 
void sigquit(); 

// driver code 
void main() 
{ 
	int pid; 

	/* get child process */
	if ((pid = fork()) < 0) 
	{ 
		perror("fork"); 
		exit(1); 
	} 
	sleep(3);
	if (pid == 0) 
	{	 /* child */
		printf("II:");
		signal(SIGHUP, sighup); 
		signal(SIGINT, sigint); 
		signal(SIGQUIT, sigquit); 
		for (;;); 
		/* loop for ever */
	} 

	else /* parent */
	{ /* pid hold id of child */
		printf("\nPARENT: sending SIGHUP\n\n"); 
		kill(pid, SIGHUP); 

		sleep(3); /* pause for 3 secs */
		printf("\nPARENT: sending SIGINT\n\n"); 
		kill(pid, SIGINT); 

		sleep(3); /* pause for 3 secs */
		printf("\nPARENT: sending SIGQUIT\n\n"); 
		kill(pid, SIGQUIT); 
		sleep(3); 
	} 
} 

// sighup() function definition 
void sighup() 

{ 
	signal(SIGHUP, sighup); /* reset signal */
	printf("CHILD: I have received a SIGHUP\n"); 
} 

// sigint() function definition 
void sigint() 
{ 
	signal(SIGINT, sigint); /* reset signal */
	printf("CHILD: I have received a SIGINT\n"); 
} 

// sigquit() function definition 
void sigquit() 
{ 
	printf("My DADDY has Killed me!!!\n"); 
	exit(0); 
} 
-----------------------------------------------------------------------------------------------------------------------------
Q.22)
/*Write a C program to implement the following unix/linux command (use fork, pipe and exec system call). Your program should block the signal Ctrl-C and Ctrl-\signal during the execution. ls –l | wc –l*/

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void)
{
    int fd[2];
    pid_t pid1, pid2;

    if (pipe(fd) < 0)
        perror("pipe error"), exit(1);
    else if ((pid1 = fork()) < 0)
        perror("fork error"), exit(1);
    else if (pid1 == 0)
    {
        /* ls */
        dup2(fd[1], STDOUT_FILENO);
        close(fd[0]);
        close(fd[1]);
        execlp("ls", "ls", (char *)0);
        perror("exec ls");
        exit(1);
    }
    else if ((pid2 = fork()) < 0)
        perror("fork error"), exit(1);
    else if (pid2 == 0)
    {
        /* wc */
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        close(fd[1]);
        execlp("wc", "wc", (char *)0);
        perror("exec wc");
        exit(1);
    }
    else
    {
        close(fd[0]);
        close(fd[1]);
        int status1;
        int status2;
        int corpse1 = waitpid(pid1, &status1, 0);
        int corpse2 = waitpid(pid2, &status2, 0);
        printf("ls: pid = %d, corpse = %d, exit status = 0x%.4X\n", pid1, corpse1, status1);
        printf("ls: pid = %d, corpse = %d, exit status = 0x%.4X\n", pid2, corpse2, status2);
    }
    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
Q.23) /*Write a C Program that demonstrates redirection of standard output to a file.*/
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
void main(int argc, char *argv[])
{
	char d[50];
 	if(argc==2)
	{
		bzero(d,sizeof(d));
		strcat(d,"ls ");
		strcat(d,"> ");
		strcat(d,argv[1]);
		system(d);
	}
	else
		printf("\nInvalid No. of inputs");
}
-----------------------------------------------------------------------------------------------------------------------------
Q.24)/*Write a program that illustrates how to execute two commands concurrently with a pipe.*/
#include <stdio.h> 
#include <unistd.h> 
#include <sys/types.h> 
#include <stdlib.h> 
int main()
{
int pfds[2];
char buf[30];
if(pipe(pfds)==-1)
{
perror("pipe failed");
exit(1);
}
if(!fork())
{
close(1);
dup(pfds[1]);
system ("ls -l");
}
else
{
printf("parent reading from pipe \n");
while(read(pfds[0],buf,80))
printf("%s \n" ,buf);
}
}

-----------------------------------------------------------------------------------------------------------------------------
Q.25)
/* Write a C program that illustrates suspending and resuming processes using signals. */

#include <signal.h>
#include <stdio.h>
int main ()
{
      int pid1;
      int pid2;
      pid1 = fork();
      if (pid1 == 0) /* First child */
      {
          while (1) /* Infinite loop */
          {
               printf ("pid1 is alive\n");
               sleep (1);
          }
      }
      pid2 = fork (); /* Second child */
      if (pid2 == 0)
      {
          while (1) /* Infinite loop */
          {
               printf ("pid2 is alive\n");
               sleep (1);
          }
      }
      sleep (3);
      kill (pid1, SIGSTOP); /* Suspend first child */
      sleep (3);
      kill (pid1, SIGCONT); /* Resume first child */
      sleep (3);
      kill (pid1, SIGINT); /* Kill first child */
      kill (pid2, SIGINT); /* Kill second child */
}

----------------------------------------------------------------------------------------------------------------------
Q.26)
/*Write a C program that illustrates inters process communication using shared memory*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
Struct country
{
       Char name[30];
       Char capital_city[30];
       Char currency[30];
       Int population;
};
Int main(int argc, char *argv[])
{
       Int shm_id;
       Char *shm_addr;
       Int *countries_num;
       Struct country *countries;
       Struct shmid_ds shm_desc;
       Shm_id = shmget(100, 2048, IPC_CREAT | IPC_EXCL\0600);
       If(shm_id == -1)
       {
              Perror(“main:shmget
                     :”);
              Exit(1);
       }
       Shm_addr = shmat(shm_id, NULL, 0);
       If(!shm_addr)
       {
              Perror(“main:shmat
                     :”);
              Exit(1);
       }
       Countries_num = (int *)shm_addr;
       *countries_num = 0;
       Countries = (struct country *)((void *)shm_addr sizeof(int));
       Strcpy(countries[0], name,”U.S.A”);
       Strcpy(countries[0], capital_city,”WASHINGTON”);
       Strcpy(countries[0], currency,”U.S.DOLLAR”);
       Countries[0].population = 250000000;
       (countries_num);
       Strcpy(countries[1].name,”israel”);
       Strcpy(countries[1].capital_city,”jerushalem”);
       Strcpy(countries[1].currency,”NEW ISRAEL SHEKED”);
       Countries[1].population = 6000000;
       (*countries_num);
       Strcpy(countries[2].name,”France”);
       Strcpy(countries[2].capital_city,”paris”);
       Strcpy(countries[2].currency,”Frank”);
       Countries[2].population = 60000000;
       (*countries_num);
       For(i = 0; i < (*countries_num); i)
       {
              Printf(“country % d
                     :\n”, i 1);
              Printf(“name
                     : % d
                     :\n”, i 1);
              Printf(“currency
                     : % s
                     :\n”, countries[i].currency);
              Printf(“population
                     : % d
                     :\n”, countries[i].population);
       }
       If(shmdt(shm_addr) == -1)
       {
              Perror(“main:shmdt
                     :”);
       }
       If(shmctl(shm_id, IPC_RMID, &SHM_DESC) == -1)
       {
              Perror(“main:shmctl
                     :”);
       }
       return 0;
}